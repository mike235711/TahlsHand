#ifndef MOVE_H
#define MOVE_H

#include <cstdint> // For fixed-sized integers

// Moves are represented by 16bit integers
//
// bit  0- 5: origin square (from 0 to 63)                                  0000000000111111
// bit  6-11: destination square (from 0 to 63)                             0000111111000000
// bit 12-13: promotion (00 knight, 01 bishop, 10 rook, 11 queen)           0011000000000000
// bit 14-15: special move flag (promotion 01, pawn double 10, capture 11)  1100000000000000

class Move
{
private:
    uint16_t data; // Store the move data

    static std::string squareToAlgebraic(unsigned short square)
    {
        std::string file(1, "abcdefgh"[square % 8]); // Convert the char to a std::string
        std::string rank = std::to_string(square / 8 + 1);
        return file + rank;
    }

public:
    Move() : data{0} {}             // Default constructor
    explicit Move(uint16_t value) : // Bit Constructor
        data{value} {}

    explicit Move(unsigned short origin, unsigned short destination) : 
        // Normal move constructor (Non promotion, capture, castling or double pawn move)
        data{static_cast<uint16_t>(origin | (destination << 6))} {}
    
    explicit Move(unsigned short origin, unsigned short destination, unsigned short captured_piece) : 
        // Capture move constructor
        data{static_cast<uint16_t>(origin | (destination << 6) | 49152)} {}

    // Moves from king when castling. This is because this is never a move generated by the move
    // generator.

    static Move promotingMove(unsigned short origin, unsigned short destination, unsigned short promoted_piece)
        // Promotion move constructor
        {
            return Move(origin | (destination << 6) | (promoted_piece << 12) | 16384);
        }

    // Member functions

    uint16_t getData() const { return data; }

    unsigned short getOriginSquare() const
    {
        return data & 63;
    }
    unsigned short getDestinationSquare() const
    {
        return (data >> 6) & 63;
    }
    std::string toString() const
    {
        if ((data & 0b1100000000000000) != 0b0100000000000000) // Non promotions
            return squareToAlgebraic(getOriginSquare()) + squareToAlgebraic(getDestinationSquare());
        else if ((data & 0b0011000000000000) == 0b0011000000000000) // Queen promotions
            return squareToAlgebraic(getOriginSquare()) + 'q' + squareToAlgebraic(getDestinationSquare());
        else if ((data & 0b0011000000000000) == 0b0010000000000000) // Rook promotions
            return squareToAlgebraic(getOriginSquare()) + 'r' + squareToAlgebraic(getDestinationSquare());
        else if ((data & 0b0011000000000000) == 0b0001000000000000) // Bishop promotions
            return squareToAlgebraic(getOriginSquare()) + 'b' + squareToAlgebraic(getDestinationSquare());
        else // Knight promotions
            return squareToAlgebraic(getOriginSquare()) + 'n' + squareToAlgebraic(getDestinationSquare());
    }         
};

#endif
