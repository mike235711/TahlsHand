#ifndef MOVE_H
#define MOVE_H

#include <cstdint> // For fixed-sized integers

static unsigned short algebraicToSquare(const std::string &square)
{
    char file = square[0]; // 'a' to 'h'
    char rank = square[1]; // '1' to '8'

    unsigned short fileIndex = file - 'a'; // 0 to 7
    unsigned short rankIndex = '8' - rank; // 0 to 7, since rank 1 is the 8th row in 0-based index

    return rankIndex * 8 + fileIndex; // Convert to 0-based index
}
static unsigned short pieceTypeFromChar(char promotionChar)
{
    switch (promotionChar)
    {
    case 'n': // Knight
        return 0b00;
    case 'b': // Bishop
        return 0b01;
    case 'r': // Rook
        return 0b10;
    case 'q': // Queen
        return 0b11;
    default:
        // Handle invalid input if necessary
        return 0;
    }
}

// Moves are represented by 16bit integers
//
// bit  0- 5: origin square (from 0 to 63)                                           0000000000111111
// bit  6-11: destination square (from 0 to 63)                                      0000111111000000
// bit 12-13: promotion (00 knight, 01 bishop, 10 rook, 11 queen)                    0011000000000000
// bit 14-15: special move flag (promotion/castling 01, pawn double 10, capture 11)  1100000000000000

class Move
{
private:
    uint16_t data; // Store the move data

    static std::string squareToAlgebraic(unsigned short square)
    {
        std::string file(1, "abcdefgh"[square % 8]); // Convert the char to a std::string
        std::string rank = std::to_string(square / 8 + 1);
        return file + rank;
    }

public:
    Move() : data{0} {} // Default constructor
    explicit Move(uint16_t value) : // Bit Constructor
        data{value}
    {
    }

    explicit Move(unsigned short origin, unsigned short destination) : // Normal move constructor (Non promotion, capture, castling or double pawn move)
        data{static_cast<uint16_t>(origin | (destination << 6))}
    {
    }

    explicit Move(unsigned short origin, unsigned short destination, unsigned short captured_piece) : // Capture move constructor
        data{static_cast<uint16_t>(origin | (destination << 6) | 49152)}
    {
    }

    // Moves from king when castling. This is because this is never a move generated by the move
    // generator.

    static Move promotingMove(unsigned short origin, unsigned short destination, unsigned short promoted_piece)
    // Promotion move constructor
    {
        return Move(origin | (destination << 6) | (promoted_piece << 12) | 16384);
    }

    // Member functions

    uint16_t getData() const { return data; }

    unsigned short getOriginSquare() const
    {
        return data & 63;
    }
    unsigned short getDestinationSquare() const
    {
        return (data >> 6) & 63;
    }
    std::string toString() const
    {
        if ((data == 16772) || (data == 16516) || (data == 20412) || (data == 20156))
            return squareToAlgebraic(getOriginSquare()) + squareToAlgebraic(getDestinationSquare()); // Castling
        else if ((data & 0b1100000000000000) != 0b0100000000000000) // Non promotions
            return squareToAlgebraic(getOriginSquare()) + squareToAlgebraic(getDestinationSquare());
        else if ((data & 0b0011000000000000) == 0b0011000000000000) // Queen promotions
            return squareToAlgebraic(getOriginSquare()) + squareToAlgebraic(getDestinationSquare()) + 'q';
        else if ((data & 0b0011000000000000) == 0b0010000000000000) // Rook promotions
            return squareToAlgebraic(getOriginSquare()) + squareToAlgebraic(getDestinationSquare()) + 'r';
        else if ((data & 0b0011000000000000) == 0b0001000000000000) // Bishop promotions
            return squareToAlgebraic(getOriginSquare()) + squareToAlgebraic(getDestinationSquare()) + 'b';
        else // Knight promotions
            return squareToAlgebraic(getOriginSquare()) + squareToAlgebraic(getDestinationSquare()) + 'n';
    }
};

#endif